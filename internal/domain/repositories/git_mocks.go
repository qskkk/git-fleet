// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/qskkk/git-fleet/internal/domain/repositories (interfaces: GitRepository,ExecutorRepository)
//
// Generated by this command:
//
//	mockgen -package=repositories -destination=git_mocks.go github.com/qskkk/git-fleet/internal/domain/repositories GitRepository,ExecutorRepository
//

// Package repositories is a generated GoMock package.
package repositories

import (
	context "context"
	reflect "reflect"

	entities "github.com/qskkk/git-fleet/internal/domain/entities"
	gomock "go.uber.org/mock/gomock"
)

// MockGitRepository is a mock of GitRepository interface.
type MockGitRepository struct {
	ctrl     *gomock.Controller
	recorder *MockGitRepositoryMockRecorder
	isgomock struct{}
}

// MockGitRepositoryMockRecorder is the mock recorder for MockGitRepository.
type MockGitRepositoryMockRecorder struct {
	mock *MockGitRepository
}

// NewMockGitRepository creates a new mock instance.
func NewMockGitRepository(ctrl *gomock.Controller) *MockGitRepository {
	mock := &MockGitRepository{ctrl: ctrl}
	mock.recorder = &MockGitRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitRepository) EXPECT() *MockGitRepositoryMockRecorder {
	return m.recorder
}

// ExecuteCommand mocks base method.
func (m *MockGitRepository) ExecuteCommand(ctx context.Context, repo *entities.Repository, cmd *entities.Command) (*entities.ExecutionResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteCommand", ctx, repo, cmd)
	ret0, _ := ret[0].(*entities.ExecutionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteCommand indicates an expected call of ExecuteCommand.
func (mr *MockGitRepositoryMockRecorder) ExecuteCommand(ctx, repo, cmd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteCommand", reflect.TypeOf((*MockGitRepository)(nil).ExecuteCommand), ctx, repo, cmd)
}

// ExecuteShellCommand mocks base method.
func (m *MockGitRepository) ExecuteShellCommand(ctx context.Context, repo *entities.Repository, cmd *entities.Command) (*entities.ExecutionResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteShellCommand", ctx, repo, cmd)
	ret0, _ := ret[0].(*entities.ExecutionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteShellCommand indicates an expected call of ExecuteShellCommand.
func (mr *MockGitRepositoryMockRecorder) ExecuteShellCommand(ctx, repo, cmd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteShellCommand", reflect.TypeOf((*MockGitRepository)(nil).ExecuteShellCommand), ctx, repo, cmd)
}

// GetAheadBehind mocks base method.
func (m *MockGitRepository) GetAheadBehind(ctx context.Context, repo *entities.Repository) (int, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAheadBehind", ctx, repo)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetAheadBehind indicates an expected call of GetAheadBehind.
func (mr *MockGitRepositoryMockRecorder) GetAheadBehind(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAheadBehind", reflect.TypeOf((*MockGitRepository)(nil).GetAheadBehind), ctx, repo)
}

// GetBranch mocks base method.
func (m *MockGitRepository) GetBranch(ctx context.Context, repo *entities.Repository) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBranch", ctx, repo)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBranch indicates an expected call of GetBranch.
func (mr *MockGitRepositoryMockRecorder) GetBranch(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBranch", reflect.TypeOf((*MockGitRepository)(nil).GetBranch), ctx, repo)
}

// GetFileChanges mocks base method.
func (m *MockGitRepository) GetFileChanges(ctx context.Context, repo *entities.Repository) (int, int, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFileChanges", ctx, repo)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(int)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetFileChanges indicates an expected call of GetFileChanges.
func (mr *MockGitRepositoryMockRecorder) GetFileChanges(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFileChanges", reflect.TypeOf((*MockGitRepository)(nil).GetFileChanges), ctx, repo)
}

// GetLastCommit mocks base method.
func (m *MockGitRepository) GetLastCommit(ctx context.Context, repo *entities.Repository) (*CommitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLastCommit", ctx, repo)
	ret0, _ := ret[0].(*CommitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLastCommit indicates an expected call of GetLastCommit.
func (mr *MockGitRepositoryMockRecorder) GetLastCommit(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLastCommit", reflect.TypeOf((*MockGitRepository)(nil).GetLastCommit), ctx, repo)
}

// GetRemotes mocks base method.
func (m *MockGitRepository) GetRemotes(ctx context.Context, repo *entities.Repository) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRemotes", ctx, repo)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRemotes indicates an expected call of GetRemotes.
func (mr *MockGitRepositoryMockRecorder) GetRemotes(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRemotes", reflect.TypeOf((*MockGitRepository)(nil).GetRemotes), ctx, repo)
}

// GetStatus mocks base method.
func (m *MockGitRepository) GetStatus(ctx context.Context, repo *entities.Repository) (*entities.Repository, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStatus", ctx, repo)
	ret0, _ := ret[0].(*entities.Repository)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStatus indicates an expected call of GetStatus.
func (mr *MockGitRepositoryMockRecorder) GetStatus(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStatus", reflect.TypeOf((*MockGitRepository)(nil).GetStatus), ctx, repo)
}

// HasUncommittedChanges mocks base method.
func (m *MockGitRepository) HasUncommittedChanges(ctx context.Context, repo *entities.Repository) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasUncommittedChanges", ctx, repo)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasUncommittedChanges indicates an expected call of HasUncommittedChanges.
func (mr *MockGitRepositoryMockRecorder) HasUncommittedChanges(ctx, repo any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasUncommittedChanges", reflect.TypeOf((*MockGitRepository)(nil).HasUncommittedChanges), ctx, repo)
}

// IsValidDirectory mocks base method.
func (m *MockGitRepository) IsValidDirectory(ctx context.Context, path string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsValidDirectory", ctx, path)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsValidDirectory indicates an expected call of IsValidDirectory.
func (mr *MockGitRepositoryMockRecorder) IsValidDirectory(ctx, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsValidDirectory", reflect.TypeOf((*MockGitRepository)(nil).IsValidDirectory), ctx, path)
}

// IsValidRepository mocks base method.
func (m *MockGitRepository) IsValidRepository(ctx context.Context, path string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsValidRepository", ctx, path)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsValidRepository indicates an expected call of IsValidRepository.
func (mr *MockGitRepositoryMockRecorder) IsValidRepository(ctx, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsValidRepository", reflect.TypeOf((*MockGitRepository)(nil).IsValidRepository), ctx, path)
}

// MockExecutorRepository is a mock of ExecutorRepository interface.
type MockExecutorRepository struct {
	ctrl     *gomock.Controller
	recorder *MockExecutorRepositoryMockRecorder
	isgomock struct{}
}

// MockExecutorRepositoryMockRecorder is the mock recorder for MockExecutorRepository.
type MockExecutorRepositoryMockRecorder struct {
	mock *MockExecutorRepository
}

// NewMockExecutorRepository creates a new mock instance.
func NewMockExecutorRepository(ctrl *gomock.Controller) *MockExecutorRepository {
	mock := &MockExecutorRepository{ctrl: ctrl}
	mock.recorder = &MockExecutorRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExecutorRepository) EXPECT() *MockExecutorRepositoryMockRecorder {
	return m.recorder
}

// Cancel mocks base method.
func (m *MockExecutorRepository) Cancel(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Cancel", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Cancel indicates an expected call of Cancel.
func (mr *MockExecutorRepositoryMockRecorder) Cancel(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cancel", reflect.TypeOf((*MockExecutorRepository)(nil).Cancel), ctx)
}

// ExecuteInParallel mocks base method.
func (m *MockExecutorRepository) ExecuteInParallel(ctx context.Context, repos []*entities.Repository, cmd *entities.Command) (*entities.Summary, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteInParallel", ctx, repos, cmd)
	ret0, _ := ret[0].(*entities.Summary)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteInParallel indicates an expected call of ExecuteInParallel.
func (mr *MockExecutorRepositoryMockRecorder) ExecuteInParallel(ctx, repos, cmd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteInParallel", reflect.TypeOf((*MockExecutorRepository)(nil).ExecuteInParallel), ctx, repos, cmd)
}

// ExecuteSequential mocks base method.
func (m *MockExecutorRepository) ExecuteSequential(ctx context.Context, repos []*entities.Repository, cmd *entities.Command) (*entities.Summary, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteSequential", ctx, repos, cmd)
	ret0, _ := ret[0].(*entities.Summary)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteSequential indicates an expected call of ExecuteSequential.
func (mr *MockExecutorRepositoryMockRecorder) ExecuteSequential(ctx, repos, cmd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteSequential", reflect.TypeOf((*MockExecutorRepository)(nil).ExecuteSequential), ctx, repos, cmd)
}

// ExecuteSingle mocks base method.
func (m *MockExecutorRepository) ExecuteSingle(ctx context.Context, repo *entities.Repository, cmd *entities.Command) (*entities.ExecutionResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteSingle", ctx, repo, cmd)
	ret0, _ := ret[0].(*entities.ExecutionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteSingle indicates an expected call of ExecuteSingle.
func (mr *MockExecutorRepositoryMockRecorder) ExecuteSingle(ctx, repo, cmd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteSingle", reflect.TypeOf((*MockExecutorRepository)(nil).ExecuteSingle), ctx, repo, cmd)
}

// GetRunningExecutions mocks base method.
func (m *MockExecutorRepository) GetRunningExecutions(ctx context.Context) ([]*entities.ExecutionResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRunningExecutions", ctx)
	ret0, _ := ret[0].([]*entities.ExecutionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRunningExecutions indicates an expected call of GetRunningExecutions.
func (mr *MockExecutorRepositoryMockRecorder) GetRunningExecutions(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRunningExecutions", reflect.TypeOf((*MockExecutorRepository)(nil).GetRunningExecutions), ctx)
}
